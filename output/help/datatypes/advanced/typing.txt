Help on module typing:

NAME
    typing - The typing module: Support for gradual typing as defined by PEP 484.

MODULE REFERENCE
    https://docs.python.org/3.9/library/typing
    
    The following documentation is automatically generated from the Python
    source files.  It may be incomplete, incorrect or include features that
    are considered implementation detail and may vary between Python
    implementations.  When in doubt, consult the module reference at the
    location listed above.

DESCRIPTION
    At large scale, the structure of the module is following:
    * Imports and exports, all public names should be explicitly added to __all__.
    * Internal helper functions: these should never be used in code outside this module.
    * _SpecialForm and its instances (special forms): Any, NoReturn, ClassVar, Union, Optional
    * Two classes whose instances can be type arguments in addition to types: ForwardRef and TypeVar
    * The core of internal generics API: _GenericAlias and _VariadicGenericAlias, the latter is
      currently only used by Tuple and Callable. All subscripted types like X[int], Union[int, str],
      etc., are instances of either of these classes.
    * The public counterpart of the generics API consists of two classes: Generic and Protocol.
    * Public helper functions: get_type_hints, overload, cast, no_type_check,
      no_type_check_decorator.
    * Generic aliases for collections.abc ABCs and few additional protocols.
    * Special types: NewType, NamedTuple, TypedDict.
    * Wrapper submodules for re and io related types.

CLASSES
    builtins.object
        builtins.str
        Annotated
        Generic
            IO
                BinaryIO
                TextIO
            Protocol
                SupportsAbs
                SupportsBytes
                SupportsComplex
                SupportsFloat
                SupportsIndex
                SupportsInt
                SupportsRound
    _Final(builtins.object)
        ForwardRef
        TypeVar(_Final, _Immutable)
    _Immutable(builtins.object)
        TypeVar(_Final, _Immutable)
    
    class Annotated(builtins.object)
     |  Annotated(*args, **kwargs)
     |  
     |  Add context specific metadata to a type.
     |  
     |  Example: Annotated[int, runtime_check.Unsigned] indicates to the
     |  hypothetical runtime_check module that this type is an unsigned int.
     |  Every other consumer of this type can ignore this metadata and treat
     |  this type as int.
     |  
     |  The first argument to Annotated must be a valid type.
     |  
     |  Details:
     |  
     |  - It's an error to call `Annotated` with less than two arguments.
     |  - Nested Annotated are flattened::
     |  
     |      Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]
     |  
     |  - Instantiating an annotated type is equivalent to instantiating the
     |  underlying type::
     |  
     |      Annotated[C, Ann1](5) == C(5)
     |  
     |  - Annotated can be used as a generic type alias::
     |  
     |      Optimized = Annotated[T, runtime.Optimize()]
     |      Optimized[int] == Annotated[int, runtime.Optimize()]
     |  
     |      OptimizedList = Annotated[List[T], runtime.Optimize()]
     |      OptimizedList[int] == Annotated[List[int], runtime.Optimize()]
     |  
     |  Class methods defined here:
     |  
     |  __class_getitem__(params) from builtins.type
     |  
     |  __init_subclass__(*args, **kwargs) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(cls, *args, **kwargs)
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class BinaryIO(IO)
     |  Typed version of the return of open() in binary mode.
     |  
     |  Method resolution order:
     |      BinaryIO
     |      IO
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __enter__(self) -> 'BinaryIO'
     |  
     |  write(self, s: Union[bytes, bytearray]) -> int
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __orig_bases__ = (typing.IO[bytes],)
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from IO:
     |  
     |  __exit__(self, type, value, traceback) -> None
     |  
     |  close(self) -> None
     |  
     |  fileno(self) -> int
     |  
     |  flush(self) -> None
     |  
     |  isatty(self) -> bool
     |  
     |  read(self, n: int = -1) -> ~AnyStr
     |  
     |  readable(self) -> bool
     |  
     |  readline(self, limit: int = -1) -> ~AnyStr
     |  
     |  readlines(self, hint: int = -1) -> List[~AnyStr]
     |  
     |  seek(self, offset: int, whence: int = 0) -> int
     |  
     |  seekable(self) -> bool
     |  
     |  tell(self) -> int
     |  
     |  truncate(self, size: int = None) -> int
     |  
     |  writable(self) -> bool
     |  
     |  writelines(self, lines: List[~AnyStr]) -> None
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from IO:
     |  
     |  closed
     |  
     |  mode
     |  
     |  name
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from builtins.type
     |  
     |  __init_subclass__(*args, **kwargs) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class ForwardRef(_Final)
     |  ForwardRef(arg, is_argument=True, module=None, *, is_class=False)
     |  
     |  Internal wrapper to hold a forward reference.
     |  
     |  Method resolution order:
     |      ForwardRef
     |      _Final
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __init__(self, arg, is_argument=True, module=None, *, is_class=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __forward_arg__
     |  
     |  __forward_code__
     |  
     |  __forward_evaluated__
     |  
     |  __forward_is_argument__
     |  
     |  __forward_is_class__
     |  
     |  __forward_module__
     |  
     |  __forward_value__
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from _Final:
     |  
     |  __init_subclass__(*args, **kwds) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _Final:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Generic(builtins.object)
     |  Abstract base class for generic types.
     |  
     |  A generic type is typically declared by inheriting from
     |  this class parameterized with one or more type variables.
     |  For example, a generic mapping type might be defined as::
     |  
     |    class Mapping(Generic[KT, VT]):
     |        def __getitem__(self, key: KT) -> VT:
     |            ...
     |        # Etc.
     |  
     |  This class can then be used as follows::
     |  
     |    def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
     |        try:
     |            return mapping[key]
     |        except KeyError:
     |            return default
     |  
     |  Class methods defined here:
     |  
     |  __class_getitem__(params) from builtins.type
     |  
     |  __init_subclass__(*args, **kwargs) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class IO(Generic)
     |  Generic base class for TextIO and BinaryIO.
     |  
     |  This is an abstract, generic version of the return of open().
     |  
     |  NOTE: This does not distinguish between the different possible
     |  classes (text vs. binary, read vs. write vs. read/write,
     |  append-only, unbuffered).  The TextIO and BinaryIO subclasses
     |  below capture the distinctions between text vs. binary, which is
     |  pervasive in the interface; however we currently do not offer a
     |  way to track the other distinctions in the type system.
     |  
     |  Method resolution order:
     |      IO
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __enter__(self) -> 'IO[AnyStr]'
     |  
     |  __exit__(self, type, value, traceback) -> None
     |  
     |  close(self) -> None
     |  
     |  fileno(self) -> int
     |  
     |  flush(self) -> None
     |  
     |  isatty(self) -> bool
     |  
     |  read(self, n: int = -1) -> ~AnyStr
     |  
     |  readable(self) -> bool
     |  
     |  readline(self, limit: int = -1) -> ~AnyStr
     |  
     |  readlines(self, hint: int = -1) -> List[~AnyStr]
     |  
     |  seek(self, offset: int, whence: int = 0) -> int
     |  
     |  seekable(self) -> bool
     |  
     |  tell(self) -> int
     |  
     |  truncate(self, size: int = None) -> int
     |  
     |  writable(self) -> bool
     |  
     |  write(self, s: ~AnyStr) -> int
     |  
     |  writelines(self, lines: List[~AnyStr]) -> None
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  closed
     |  
     |  mode
     |  
     |  name
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __orig_bases__ = (typing.Generic[~AnyStr],)
     |  
     |  __parameters__ = (~AnyStr,)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from builtins.type
     |  
     |  __init_subclass__(*args, **kwargs) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class Protocol(Generic)
     |  Base class for protocol classes.
     |  
     |  Protocol classes are defined as::
     |  
     |      class Proto(Protocol):
     |          def meth(self) -> int:
     |              ...
     |  
     |  Such classes are primarily used with static type checkers that recognize
     |  structural subtyping (static duck-typing), for example::
     |  
     |      class C:
     |          def meth(self) -> int:
     |              return 0
     |  
     |      def func(x: Proto) -> int:
     |          return x.meth()
     |  
     |      func(C())  # Passes static type check
     |  
     |  See PEP 544 for details. Protocol classes decorated with
     |  @typing.runtime_checkable act as simple-minded runtime protocols that check
     |  only the presence of given attributes, ignoring their type signatures.
     |  Protocol classes can be generic, they are defined as::
     |  
     |      class GenProto(Protocol[T]):
     |          def meth(self) -> T:
     |              ...
     |  
     |  Method resolution order:
     |      Protocol
     |      Generic
     |      builtins.object
     |  
     |  Class methods defined here:
     |  
     |  __init_subclass__(*args, **kwargs) from _ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from _ProtocolMeta
    
    class SupportsAbs(Protocol)
     |  SupportsAbs(*args, **kwargs)
     |  
     |  An ABC with one abstract method __abs__ that is covariant in its return type.
     |  
     |  Method resolution order:
     |      SupportsAbs
     |      Protocol
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __abs__(self) -> +T_co
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__abs__'})
     |  
     |  __orig_bases__ = (typing.Protocol[+T_co],)
     |  
     |  __parameters__ = (+T_co,)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from _ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from _ProtocolMeta
    
    class SupportsBytes(Protocol)
     |  SupportsBytes(*args, **kwargs)
     |  
     |  An ABC with one abstract method __bytes__.
     |  
     |  Method resolution order:
     |      SupportsBytes
     |      Protocol
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __bytes__(self) -> bytes
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__bytes__'})
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from _ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from _ProtocolMeta
    
    class SupportsComplex(Protocol)
     |  SupportsComplex(*args, **kwargs)
     |  
     |  An ABC with one abstract method __complex__.
     |  
     |  Method resolution order:
     |      SupportsComplex
     |      Protocol
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __complex__(self) -> complex
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__complex__'})
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from _ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from _ProtocolMeta
    
    class SupportsFloat(Protocol)
     |  SupportsFloat(*args, **kwargs)
     |  
     |  An ABC with one abstract method __float__.
     |  
     |  Method resolution order:
     |      SupportsFloat
     |      Protocol
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __float__(self) -> float
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__float__'})
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from _ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from _ProtocolMeta
    
    class SupportsIndex(Protocol)
     |  SupportsIndex(*args, **kwargs)
     |  
     |  An ABC with one abstract method __index__.
     |  
     |  Method resolution order:
     |      SupportsIndex
     |      Protocol
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __index__(self) -> int
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__index__'})
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from _ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from _ProtocolMeta
    
    class SupportsInt(Protocol)
     |  SupportsInt(*args, **kwargs)
     |  
     |  An ABC with one abstract method __int__.
     |  
     |  Method resolution order:
     |      SupportsInt
     |      Protocol
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __int__(self) -> int
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__int__'})
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from _ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from _ProtocolMeta
    
    class SupportsRound(Protocol)
     |  SupportsRound(*args, **kwargs)
     |  
     |  An ABC with one abstract method __round__ that is covariant in its return type.
     |  
     |  Method resolution order:
     |      SupportsRound
     |      Protocol
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __round__(self, ndigits: int = 0) -> +T_co
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__round__'})
     |  
     |  __orig_bases__ = (typing.Protocol[+T_co],)
     |  
     |  __parameters__ = (+T_co,)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from _ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from _ProtocolMeta
    
    Text = class str(object)
     |  str(object='') -> str
     |  str(bytes_or_buffer[, encoding[, errors]]) -> str
     |  
     |  Create a new string object from the given object. If encoding or
     |  errors is specified, then the object must expose a data buffer
     |  that will be decoded using the given encoding and error handler.
     |  Otherwise, returns the result of object.__str__() (if defined)
     |  or repr(object).
     |  encoding defaults to sys.getdefaultencoding().
     |  errors defaults to 'strict'.
     |  
     |  Methods defined here:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __format__(self, format_spec, /)
     |      Return a formatted version of the string as described by format_spec.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __getnewargs__(...)
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mod__(self, value, /)
     |      Return self%value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __rmod__(self, value, /)
     |      Return value%self.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  __sizeof__(self, /)
     |      Return the size of the string in memory, in bytes.
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  capitalize(self, /)
     |      Return a capitalized version of the string.
     |      
     |      More specifically, make the first character have upper case and the rest lower
     |      case.
     |  
     |  casefold(self, /)
     |      Return a version of the string suitable for caseless comparisons.
     |  
     |  center(self, width, fillchar=' ', /)
     |      Return a centered string of length width.
     |      
     |      Padding is done using the specified fill character (default is a space).
     |  
     |  count(...)
     |      S.count(sub[, start[, end]]) -> int
     |      
     |      Return the number of non-overlapping occurrences of substring sub in
     |      string S[start:end].  Optional arguments start and end are
     |      interpreted as in slice notation.
     |  
     |  encode(self, /, encoding='utf-8', errors='strict')
     |      Encode the string using the codec registered for encoding.
     |      
     |      encoding
     |        The encoding in which to encode the string.
     |      errors
     |        The error handling scheme to use for encoding errors.
     |        The default is 'strict' meaning that encoding errors raise a
     |        UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
     |        'xmlcharrefreplace' as well as any other name registered with
     |        codecs.register_error that can handle UnicodeEncodeErrors.
     |  
     |  endswith(...)
     |      S.endswith(suffix[, start[, end]]) -> bool
     |      
     |      Return True if S ends with the specified suffix, False otherwise.
     |      With optional start, test S beginning at that position.
     |      With optional end, stop comparing S at that position.
     |      suffix can also be a tuple of strings to try.
     |  
     |  expandtabs(self, /, tabsize=8)
     |      Return a copy where all tab characters are expanded using spaces.
     |      
     |      If tabsize is not given, a tab size of 8 characters is assumed.
     |  
     |  find(...)
     |      S.find(sub[, start[, end]]) -> int
     |      
     |      Return the lowest index in S where substring sub is found,
     |      such that sub is contained within S[start:end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Return -1 on failure.
     |  
     |  format(...)
     |      S.format(*args, **kwargs) -> str
     |      
     |      Return a formatted version of S, using substitutions from args and kwargs.
     |      The substitutions are identified by braces ('{' and '}').
     |  
     |  format_map(...)
     |      S.format_map(mapping) -> str
     |      
     |      Return a formatted version of S, using substitutions from mapping.
     |      The substitutions are identified by braces ('{' and '}').
     |  
     |  index(...)
     |      S.index(sub[, start[, end]]) -> int
     |      
     |      Return the lowest index in S where substring sub is found,
     |      such that sub is contained within S[start:end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Raises ValueError when the substring is not found.
     |  
     |  isalnum(self, /)
     |      Return True if the string is an alpha-numeric string, False otherwise.
     |      
     |      A string is alpha-numeric if all characters in the string are alpha-numeric and
     |      there is at least one character in the string.
     |  
     |  isalpha(self, /)
     |      Return True if the string is an alphabetic string, False otherwise.
     |      
     |      A string is alphabetic if all characters in the string are alphabetic and there
     |      is at least one character in the string.
     |  
     |  isascii(self, /)
     |      Return True if all characters in the string are ASCII, False otherwise.
     |      
     |      ASCII characters have code points in the range U+0000-U+007F.
     |      Empty string is ASCII too.
     |  
     |  isdecimal(self, /)
     |      Return True if the string is a decimal string, False otherwise.
     |      
     |      A string is a decimal string if all characters in the string are decimal and
     |      there is at least one character in the string.
     |  
     |  isdigit(self, /)
     |      Return True if the string is a digit string, False otherwise.
     |      
     |      A string is a digit string if all characters in the string are digits and there
     |      is at least one character in the string.
     |  
     |  isidentifier(self, /)
     |      Return True if the string is a valid Python identifier, False otherwise.
     |      
     |      Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
     |      such as "def" or "class".
     |  
     |  islower(self, /)
     |      Return True if the string is a lowercase string, False otherwise.
     |      
     |      A string is lowercase if all cased characters in the string are lowercase and
     |      there is at least one cased character in the string.
     |  
     |  isnumeric(self, /)
     |      Return True if the string is a numeric string, False otherwise.
     |      
     |      A string is numeric if all characters in the string are numeric and there is at
     |      least one character in the string.
     |  
     |  isprintable(self, /)
     |      Return True if the string is printable, False otherwise.
     |      
     |      A string is printable if all of its characters are considered printable in
     |      repr() or if it is empty.
     |  
     |  isspace(self, /)
     |      Return True if the string is a whitespace string, False otherwise.
     |      
     |      A string is whitespace if all characters in the string are whitespace and there
     |      is at least one character in the string.
     |  
     |  istitle(self, /)
     |      Return True if the string is a title-cased string, False otherwise.
     |      
     |      In a title-cased string, upper- and title-case characters may only
     |      follow uncased characters and lowercase characters only cased ones.
     |  
     |  isupper(self, /)
     |      Return True if the string is an uppercase string, False otherwise.
     |      
     |      A string is uppercase if all cased characters in the string are uppercase and
     |      there is at least one cased character in the string.
     |  
     |  join(self, iterable, /)
     |      Concatenate any number of strings.
     |      
     |      The string whose method is called is inserted in between each given string.
     |      The result is returned as a new string.
     |      
     |      Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
     |  
     |  ljust(self, width, fillchar=' ', /)
     |      Return a left-justified string of length width.
     |      
     |      Padding is done using the specified fill character (default is a space).
     |  
     |  lower(self, /)
     |      Return a copy of the string converted to lowercase.
     |  
     |  lstrip(self, chars=None, /)
     |      Return a copy of the string with leading whitespace removed.
     |      
     |      If chars is given and not None, remove characters in chars instead.
     |  
     |  partition(self, sep, /)
     |      Partition the string into three parts using the given separator.
     |      
     |      This will search for the separator in the string.  If the separator is found,
     |      returns a 3-tuple containing the part before the separator, the separator
     |      itself, and the part after it.
     |      
     |      If the separator is not found, returns a 3-tuple containing the original string
     |      and two empty strings.
     |  
     |  removeprefix(self, prefix, /)
     |      Return a str with the given prefix string removed if present.
     |      
     |      If the string starts with the prefix string, return string[len(prefix):].
     |      Otherwise, return a copy of the original string.
     |  
     |  removesuffix(self, suffix, /)
     |      Return a str with the given suffix string removed if present.
     |      
     |      If the string ends with the suffix string and that suffix is not empty,
     |      return string[:-len(suffix)]. Otherwise, return a copy of the original
     |      string.
     |  
     |  replace(self, old, new, count=-1, /)
     |      Return a copy with all occurrences of substring old replaced by new.
     |      
     |        count
     |          Maximum number of occurrences to replace.
     |          -1 (the default value) means replace all occurrences.
     |      
     |      If the optional argument count is given, only the first count occurrences are
     |      replaced.
     |  
     |  rfind(...)
     |      S.rfind(sub[, start[, end]]) -> int
     |      
     |      Return the highest index in S where substring sub is found,
     |      such that sub is contained within S[start:end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Return -1 on failure.
     |  
     |  rindex(...)
     |      S.rindex(sub[, start[, end]]) -> int
     |      
     |      Return the highest index in S where substring sub is found,
     |      such that sub is contained within S[start:end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Raises ValueError when the substring is not found.
     |  
     |  rjust(self, width, fillchar=' ', /)
     |      Return a right-justified string of length width.
     |      
     |      Padding is done using the specified fill character (default is a space).
     |  
     |  rpartition(self, sep, /)
     |      Partition the string into three parts using the given separator.
     |      
     |      This will search for the separator in the string, starting at the end. If
     |      the separator is found, returns a 3-tuple containing the part before the
     |      separator, the separator itself, and the part after it.
     |      
     |      If the separator is not found, returns a 3-tuple containing two empty strings
     |      and the original string.
     |  
     |  rsplit(self, /, sep=None, maxsplit=-1)
     |      Return a list of the words in the string, using sep as the delimiter string.
     |      
     |        sep
     |          The delimiter according which to split the string.
     |          None (the default value) means split according to any whitespace,
     |          and discard empty strings from the result.
     |        maxsplit
     |          Maximum number of splits to do.
     |          -1 (the default value) means no limit.
     |      
     |      Splits are done starting at the end of the string and working to the front.
     |  
     |  rstrip(self, chars=None, /)
     |      Return a copy of the string with trailing whitespace removed.
     |      
     |      If chars is given and not None, remove characters in chars instead.
     |  
     |  split(self, /, sep=None, maxsplit=-1)
     |      Return a list of the words in the string, using sep as the delimiter string.
     |      
     |      sep
     |        The delimiter according which to split the string.
     |        None (the default value) means split according to any whitespace,
     |        and discard empty strings from the result.
     |      maxsplit
     |        Maximum number of splits to do.
     |        -1 (the default value) means no limit.
     |  
     |  splitlines(self, /, keepends=False)
     |      Return a list of the lines in the string, breaking at line boundaries.
     |      
     |      Line breaks are not included in the resulting list unless keepends is given and
     |      true.
     |  
     |  startswith(...)
     |      S.startswith(prefix[, start[, end]]) -> bool
     |      
     |      Return True if S starts with the specified prefix, False otherwise.
     |      With optional start, test S beginning at that position.
     |      With optional end, stop comparing S at that position.
     |      prefix can also be a tuple of strings to try.
     |  
     |  strip(self, chars=None, /)
     |      Return a copy of the string with leading and trailing whitespace removed.
     |      
     |      If chars is given and not None, remove characters in chars instead.
     |  
     |  swapcase(self, /)
     |      Convert uppercase characters to lowercase and lowercase characters to uppercase.
     |  
     |  title(self, /)
     |      Return a version of the string where each word is titlecased.
     |      
     |      More specifically, words start with uppercased characters and all remaining
     |      cased characters have lower case.
     |  
     |  translate(self, table, /)
     |      Replace each character in the string using the given translation table.
     |      
     |        table
     |          Translation table, which must be a mapping of Unicode ordinals to
     |          Unicode ordinals, strings, or None.
     |      
     |      The table must implement lookup/indexing via __getitem__, for instance a
     |      dictionary or list.  If this operation raises LookupError, the character is
     |      left untouched.  Characters mapped to None are deleted.
     |  
     |  upper(self, /)
     |      Return a copy of the string converted to uppercase.
     |  
     |  zfill(self, width, /)
     |      Pad a numeric string with zeros on the left, to fill a field of the given width.
     |      
     |      The string is never truncated.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  maketrans(...)
     |      Return a translation table usable for str.translate().
     |      
     |      If there is only one argument, it must be a dictionary mapping Unicode
     |      ordinals (integers) or characters to Unicode ordinals, strings or None.
     |      Character keys will be then converted to ordinals.
     |      If there are two arguments, they must be strings of equal length, and
     |      in the resulting dictionary, each character in x will be mapped to the
     |      character at the same position in y. If there is a third argument, it
     |      must be a string, whose characters will be mapped to None in the result.
    
    class TextIO(IO)
     |  Typed version of the return of open() in text mode.
     |  
     |  Method resolution order:
     |      TextIO
     |      IO
     |      Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __enter__(self) -> 'TextIO'
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  buffer
     |  
     |  encoding
     |  
     |  errors
     |  
     |  line_buffering
     |  
     |  newlines
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __orig_bases__ = (typing.IO[str],)
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from IO:
     |  
     |  __exit__(self, type, value, traceback) -> None
     |  
     |  close(self) -> None
     |  
     |  fileno(self) -> int
     |  
     |  flush(self) -> None
     |  
     |  isatty(self) -> bool
     |  
     |  read(self, n: int = -1) -> ~AnyStr
     |  
     |  readable(self) -> bool
     |  
     |  readline(self, limit: int = -1) -> ~AnyStr
     |  
     |  readlines(self, hint: int = -1) -> List[~AnyStr]
     |  
     |  seek(self, offset: int, whence: int = 0) -> int
     |  
     |  seekable(self) -> bool
     |  
     |  tell(self) -> int
     |  
     |  truncate(self, size: int = None) -> int
     |  
     |  writable(self) -> bool
     |  
     |  write(self, s: ~AnyStr) -> int
     |  
     |  writelines(self, lines: List[~AnyStr]) -> None
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from IO:
     |  
     |  closed
     |  
     |  mode
     |  
     |  name
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Generic:
     |  
     |  __class_getitem__(params) from builtins.type
     |  
     |  __init_subclass__(*args, **kwargs) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class TypeVar(_Final, _Immutable)
     |  TypeVar(name, *constraints, bound=None, covariant=False, contravariant=False)
     |  
     |  Type variable.
     |  
     |  Usage::
     |  
     |    T = TypeVar('T')  # Can be anything
     |    A = TypeVar('A', str, bytes)  # Must be str or bytes
     |  
     |  Type variables exist primarily for the benefit of static type
     |  checkers.  They serve as the parameters for generic types as well
     |  as for generic function definitions.  See class Generic for more
     |  information on generic types.  Generic functions work as follows:
     |  
     |    def repeat(x: T, n: int) -> List[T]:
     |        '''Return a list containing n references to x.'''
     |        return [x]*n
     |  
     |    def longest(x: A, y: A) -> A:
     |        '''Return the longest of two strings.'''
     |        return x if len(x) >= len(y) else y
     |  
     |  The latter example's signature is essentially the overloading
     |  of (str, str) -> str and (bytes, bytes) -> bytes.  Also note
     |  that if the arguments are instances of some subclass of str,
     |  the return type is still plain str.
     |  
     |  At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.
     |  
     |  Type variables defined with covariant=True or contravariant=True
     |  can be used to declare covariant or contravariant generic types.
     |  See PEP 484 for more details. By default generic types are invariant
     |  in all type variables.
     |  
     |  Type variables can be introspected. e.g.:
     |  
     |    T.__name__ == 'T'
     |    T.__constraints__ == ()
     |    T.__covariant__ == False
     |    T.__contravariant__ = False
     |    A.__constraints__ == (str, bytes)
     |  
     |  Note that only type variables defined in global scope can be pickled.
     |  
     |  Method resolution order:
     |      TypeVar
     |      _Final
     |      _Immutable
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, *constraints, bound=None, covariant=False, contravariant=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __reduce__(self)
     |      Helper for pickle.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __bound__
     |  
     |  __constraints__
     |  
     |  __contravariant__
     |  
     |  __covariant__
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from _Final:
     |  
     |  __init_subclass__(*args, **kwds) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _Final:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _Immutable:
     |  
     |  __copy__(self)
     |  
     |  __deepcopy__(self, memo)

FUNCTIONS
    NamedTuple(typename, fields=None, /, **kwargs)
        Typed version of namedtuple.
        
        Usage in Python versions >= 3.6::
        
            class Employee(NamedTuple):
                name: str
                id: int
        
        This is equivalent to::
        
            Employee = collections.namedtuple('Employee', ['name', 'id'])
        
        The resulting class has an extra __annotations__ attribute, giving a
        dict that maps field names to types.  (The field names are also in
        the _fields attribute, which is part of the namedtuple API.)
        Alternative equivalent keyword syntax is also accepted::
        
            Employee = NamedTuple('Employee', name=str, id=int)
        
        In Python versions <= 3.5 use::
        
            Employee = NamedTuple('Employee', [('name', str), ('id', int)])
    
    NewType(name, tp)
        NewType creates simple unique types with almost zero
        runtime overhead. NewType(name, tp) is considered a subtype of tp
        by static type checkers. At runtime, NewType(name, tp) returns
        a dummy function that simply returns its argument. Usage::
        
            UserId = NewType('UserId', int)
        
            def name_by_id(user_id: UserId) -> str:
                ...
        
            UserId('user')          # Fails type check
        
            name_by_id(42)          # Fails type check
            name_by_id(UserId(42))  # OK
        
            num = UserId(5) + 1     # type: int
    
    TypedDict(typename, fields=None, /, *, total=True, **kwargs)
        A simple typed namespace. At runtime it is equivalent to a plain dict.
        
        TypedDict creates a dictionary type that expects all of its
        instances to have a certain set of keys, where each key is
        associated with a value of a consistent type. This expectation
        is not checked at runtime but is only enforced by type checkers.
        Usage::
        
            class Point2D(TypedDict):
                x: int
                y: int
                label: str
        
            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check
        
            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')
        
        The type info can be accessed via the Point2D.__annotations__ dict, and
        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.
        TypedDict supports two additional equivalent forms::
        
            Point2D = TypedDict('Point2D', x=int, y=int, label=str)
            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})
        
        By default, all keys must be present in a TypedDict. It is possible
        to override this by specifying totality.
        Usage::
        
            class point2D(TypedDict, total=False):
                x: int
                y: int
        
        This means that a point2D TypedDict can have any of the keys omitted.A type
        checker is only expected to support a literal False or True as the value of
        the total argument. True is the default, and makes all items defined in the
        class body be required.
        
        The class syntax is only supported in Python 3.6+, while two other
        syntax forms work for Python 2.7 and 3.2+
    
    cast(typ, val)
        Cast a value to a type.
        
        This returns the value unchanged.  To the type checker this
        signals that the return value has the designated type, but at
        runtime we intentionally don't check anything (we want this
        to be as fast as possible).
    
    final(f)
        A decorator to indicate final methods and final classes.
        
        Use this decorator to indicate to type checkers that the decorated
        method cannot be overridden, and decorated class cannot be subclassed.
        For example:
        
          class Base:
              @final
              def done(self) -> None:
                  ...
          class Sub(Base):
              def done(self) -> None:  # Error reported by type checker
                    ...
        
          @final
          class Leaf:
              ...
          class Other(Leaf):  # Error reported by type checker
              ...
        
        There is no runtime checking of these properties.
    
    get_args(tp)
        Get type arguments with all substitutions performed.
        
        For unions, basic simplifications used by Union constructor are performed.
        Examples::
            get_args(Dict[str, int]) == (str, int)
            get_args(int) == ()
            get_args(Union[int, Union[T, int], str][int]) == (int, str)
            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
            get_args(Callable[[], T][int]) == ([], int)
    
    get_origin(tp)
        Get the unsubscripted version of a type.
        
        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar
        and Annotated. Return None for unsupported types. Examples::
        
            get_origin(Literal[42]) is Literal
            get_origin(int) is None
            get_origin(ClassVar[int]) is ClassVar
            get_origin(Generic) is Generic
            get_origin(Generic[T]) is Generic
            get_origin(Union[T, int]) is Union
            get_origin(List[Tuple[T, T]][int]) == list
    
    get_type_hints(obj, globalns=None, localns=None, include_extras=False)
        Return type hints for an object.
        
        This is often the same as obj.__annotations__, but it handles
        forward references encoded as string literals, adds Optional[t] if a
        default value equal to None is set and recursively replaces all
        'Annotated[T, ...]' with 'T' (unless 'include_extras=True').
        
        The argument may be a module, class, method, or function. The annotations
        are returned as a dictionary. For classes, annotations include also
        inherited members.
        
        TypeError is raised if the argument is not of a type that can contain
        annotations, and an empty dictionary is returned if no annotations are
        present.
        
        BEWARE -- the behavior of globalns and localns is counterintuitive
        (unless you are familiar with how eval() and exec() work).  The
        search order is locals first, then globals.
        
        - If no dict arguments are passed, an attempt is made to use the
          globals from obj (or the respective module's globals for classes),
          and these are also used as the locals.  If the object does not appear
          to have globals, an empty dictionary is used.
        
        - If one dict argument is passed, it is used for both globals and
          locals.
        
        - If two dict arguments are passed, they specify globals and
          locals, respectively.
    
    no_type_check(arg)
        Decorator to indicate that annotations are not type hints.
        
        The argument must be a class or function; if it is a class, it
        applies recursively to all methods and classes defined in that class
        (but not to methods defined in its superclasses or subclasses).
        
        This mutates the function(s) or class(es) in place.
    
    no_type_check_decorator(decorator)
        Decorator to give another decorator the @no_type_check effect.
        
        This wraps the decorator with something that wraps the decorated
        function in @no_type_check.
    
    overload(func)
        Decorator for overloaded functions/methods.
        
        In a stub file, place two or more stub definitions for the same
        function in a row, each decorated with @overload.  For example:
        
          @overload
          def utf8(value: None) -> None: ...
          @overload
          def utf8(value: bytes) -> bytes: ...
          @overload
          def utf8(value: str) -> bytes: ...
        
        In a non-stub file (i.e. a regular .py file), do the same but
        follow it with an implementation.  The implementation should *not*
        be decorated with @overload.  For example:
        
          @overload
          def utf8(value: None) -> None: ...
          @overload
          def utf8(value: bytes) -> bytes: ...
          @overload
          def utf8(value: str) -> bytes: ...
          def utf8(value):
              # implementation goes here
    
    runtime_checkable(cls)
        Mark a protocol class as a runtime protocol.
        
        Such protocol can be used with isinstance() and issubclass().
        Raise TypeError if applied to a non-protocol class.
        This allows a simple-minded structural check very similar to
        one trick ponies in collections.abc such as Iterable.
        For example::
        
            @runtime_checkable
            class Closable(Protocol):
                def close(self): ...
        
            assert isinstance(open('/some/file'), Closable)
        
        Warning: this will check only the presence of the required methods,
        not their type signatures!

DATA
    AbstractSet = typing.AbstractSet
        A generic version of collections.abc.Set.
    
    Any = typing.Any
        Special type indicating an unconstrained type.
        
        - Any is compatible with every type.
        - Any assumed to have all methods.
        - All values assumed to be instances of Any.
        
        Note that all the above statements are true from the point of view of
        static type checkers. At runtime, Any should not be used with instance
        or class checks.
    
    AnyStr = ~AnyStr
    AsyncContextManager = typing.AsyncContextManager
        A generic version of contextlib.AbstractAsyncContextManager.
    
    AsyncGenerator = typing.AsyncGenerator
        A generic version of collections.abc.AsyncGenerator.
    
    AsyncIterable = typing.AsyncIterable
        A generic version of collections.abc.AsyncIterable.
    
    AsyncIterator = typing.AsyncIterator
        A generic version of collections.abc.AsyncIterator.
    
    Awaitable = typing.Awaitable
        A generic version of collections.abc.Awaitable.
    
    ByteString = typing.ByteString
        A generic version of collections.abc.ByteString.
    
    Callable = typing.Callable
        Callable type; Callable[[int], str] is a function of (int) -> str.
        
        The subscription syntax must always be used with exactly two
        values: the argument list and the return type.  The argument list
        must be a list of types or ellipsis; the return type must be a single type.
        
        There is no syntax to indicate optional or keyword arguments,
        such function types are rarely used as callback types.
    
    ChainMap = typing.ChainMap
        A generic version of collections.ChainMap.
    
    ClassVar = typing.ClassVar
        Special type construct to mark class variables.
        
        An annotation wrapped in ClassVar indicates that a given
        attribute is intended to be used as a class variable and
        should not be set on instances of that class. Usage::
        
          class Starship:
              stats: ClassVar[Dict[str, int]] = {} # class variable
              damage: int = 10                     # instance variable
        
        ClassVar accepts only types and cannot be further subscribed.
        
        Note that ClassVar is not a class itself, and should not
        be used with isinstance() or issubclass().
    
    Collection = typing.Collection
        A generic version of collections.abc.Collection.
    
    Container = typing.Container
        A generic version of collections.abc.Container.
    
    ContextManager = typing.ContextManager
        A generic version of contextlib.AbstractContextManager.
    
    Coroutine = typing.Coroutine
        A generic version of collections.abc.Coroutine.
    
    Counter = typing.Counter
        A generic version of collections.Counter.
    
    DefaultDict = typing.DefaultDict
        A generic version of collections.defaultdict.
    
    Deque = typing.Deque
        A generic version of collections.deque.
    
    Dict = typing.Dict
        A generic version of dict.
    
    Final = typing.Final
        Special typing construct to indicate final names to type checkers.
        
        A final name cannot be re-assigned or overridden in a subclass.
        For example:
        
          MAX_SIZE: Final = 9000
          MAX_SIZE += 1  # Error reported by type checker
        
          class Connection:
              TIMEOUT: Final[int] = 10
        
          class FastConnector(Connection):
              TIMEOUT = 1  # Error reported by type checker
        
        There is no runtime checking of these properties.
    
    FrozenSet = typing.FrozenSet
        A generic version of frozenset.
    
    Generator = typing.Generator
        A generic version of collections.abc.Generator.
    
    Hashable = typing.Hashable
        A generic version of collections.abc.Hashable.
    
    ItemsView = typing.ItemsView
        A generic version of collections.abc.ItemsView.
    
    Iterable = typing.Iterable
        A generic version of collections.abc.Iterable.
    
    Iterator = typing.Iterator
        A generic version of collections.abc.Iterator.
    
    KeysView = typing.KeysView
        A generic version of collections.abc.KeysView.
    
    List = typing.List
        A generic version of list.
    
    Literal = typing.Literal
        Special typing form to define literal types (a.k.a. value types).
        
        This form can be used to indicate to type checkers that the corresponding
        variable or function parameter has a value equivalent to the provided
        literal (or one of several literals):
        
          def validate_simple(data: Any) -> Literal[True]:  # always returns True
              ...
        
          MODE = Literal['r', 'rb', 'w', 'wb']
          def open_helper(file: str, mode: MODE) -> str:
              ...
        
          open_helper('/some/path', 'r')  # Passes type check
          open_helper('/other/path', 'typo')  # Error in type checker
        
        Literal[...] cannot be subclassed. At runtime, an arbitrary value
        is allowed as type argument to Literal[...], but type checkers may
        impose restrictions.
    
    Mapping = typing.Mapping
        A generic version of collections.abc.Mapping.
    
    MappingView = typing.MappingView
        A generic version of collections.abc.MappingView.
    
    Match = typing.Match
        A generic version of re.Match.
    
    MutableMapping = typing.MutableMapping
        A generic version of collections.abc.MutableMapping.
    
    MutableSequence = typing.MutableSequence
        A generic version of collections.abc.MutableSequence.
    
    MutableSet = typing.MutableSet
        A generic version of collections.abc.MutableSet.
    
    NoReturn = typing.NoReturn
        Special type indicating functions that never return.
        Example::
        
          from typing import NoReturn
        
          def stop() -> NoReturn:
              raise Exception('no way')
        
        This type is invalid in other positions, e.g., ``List[NoReturn]``
        will fail in static type checkers.
    
    Optional = typing.Optional
        Optional type.
        
        Optional[X] is equivalent to Union[X, None].
    
    OrderedDict = typing.OrderedDict
        A generic version of collections.OrderedDict.
    
    Pattern = typing.Pattern
        A generic version of re.Pattern.
    
    Reversible = typing.Reversible
        A generic version of collections.abc.Reversible.
    
    Sequence = typing.Sequence
        A generic version of collections.abc.Sequence.
    
    Set = typing.Set
        A generic version of set.
    
    Sized = typing.Sized
        A generic version of collections.abc.Sized.
    
    TYPE_CHECKING = False
    Tuple = typing.Tuple
        Tuple type; Tuple[X, Y] is the cross-product type of X and Y.
        
        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.
        
        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
    
    Type = typing.Type
        A special construct usable to annotate class objects.
        
        For example, suppose we have the following classes::
        
          class User: ...  # Abstract base for User classes
          class BasicUser(User): ...
          class ProUser(User): ...
          class TeamUser(User): ...
        
        And a function that takes a class argument that's a subclass of
        User and returns an instance of the corresponding class::
        
          U = TypeVar('U', bound=User)
          def new_user(user_class: Type[U]) -> U:
              user = user_class()
              # (Here we could write the user object to a database)
              return user
        
          joe = new_user(BasicUser)
        
        At this point the type checker knows that joe has type BasicUser.
    
    Union = typing.Union
        Union type; Union[X, Y] means either X or Y.
        
        To define a union, use e.g. Union[int, str].  Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::
        
            Union[Union[int, str], float] == Union[int, str, float]
        
        - Unions of a single argument vanish, e.g.::
        
            Union[int] == int  # The constructor actually returns int
        
        - Redundant arguments are skipped, e.g.::
        
            Union[int, str, int] == Union[int, str]
        
        - When comparing unions, the argument order is ignored, e.g.::
        
            Union[int, str] == Union[str, int]
        
        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].
    
    ValuesView = typing.ValuesView
        A generic version of collections.abc.ValuesView.
    
    __all__ = ['Annotated', 'Any', 'Callable', 'ClassVar', 'Final', 'Forwa...

FILE
    c:\program files\python39\lib\typing.py


