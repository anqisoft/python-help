Help on package setuptools:

NAME
    setuptools - Extensions to the 'distutils' for large or complex distributions

PACKAGE CONTENTS
    _deprecation_warning
    _distutils (package)
    _entry_points
    _imp
    _importlib
    _itertools
    _path
    _reqs
    _vendor (package)
    archive_util
    build_meta
    command (package)
    config (package)
    dep_util
    depends
    discovery
    dist
    errors
    extension
    extern (package)
    glob
    installer
    launch
    logging
    monkey
    msvc
    namespaces
    package_index
    py34compat
    sandbox
    unicode_utils
    version
    wheel
    windows_support

CLASSES
    builtins.Warning(builtins.Exception)
        setuptools._deprecation_warning.SetuptoolsDeprecationWarning
    builtins.object
        setuptools.depends.Require
    distutils.cmd.Command(builtins.object)
        Command
    distutils.dist.Distribution(builtins.object)
        setuptools.dist.Distribution
    distutils.extension.Extension(builtins.object)
        setuptools.extension.Extension
    
    class Command(distutils.cmd.Command)
     |  Command(dist, **kw)
     |  
     |  Setuptools internal actions are organized using a *command design pattern*.
     |  This means that each action (or group of closely related actions) executed during
     |  the build should be implemented as a ``Command`` subclass.
     |  
     |  These commands are abstractions and do not necessarily correspond to a command that
     |  can (or should) be executed via a terminal, in a CLI fashion (although historically
     |  they would).
     |  
     |  When creating a new command from scratch, custom defined classes **SHOULD** inherit
     |  from ``setuptools.Command`` and implement a few mandatory methods.
     |  Between these mandatory methods, are listed:
     |  
     |  .. method:: initialize_options(self)
     |  
     |      Set or (reset) all options/attributes/caches used by the command
     |      to their default values. Note that these values may be overwritten during
     |      the build.
     |  
     |  .. method:: finalize_options(self)
     |  
     |      Set final values for all options/attributes used by the command.
     |      Most of the time, each option/attribute/cache should only be set if it does not
     |      have any value yet (e.g. ``if self.attr is None: self.attr = val``).
     |  
     |  .. method:: run(self)
     |  
     |      Execute the actions intended by the command.
     |      (Side effects **SHOULD** only take place when ``run`` is executed,
     |      for example, creating new files or writing to the terminal output).
     |  
     |  A useful analogy for command classes is to think of them as subroutines with local
     |  variables called "options".  The options are "declared" in ``initialize_options()``
     |  and "defined" (given their final values, aka "finalized") in ``finalize_options()``,
     |  both of which must be defined by every command class. The "body" of the subroutine,
     |  (where it does all the work) is the ``run()`` method.
     |  Between ``initialize_options()`` and ``finalize_options()``, ``setuptools`` may set
     |  the values for options/attributes based on user's input (or circumstance),
     |  which means that the implementation should be careful to not overwrite values in
     |  ``finalize_options`` unless necessary.
     |  
     |  Please note that other commands (or other parts of setuptools) may also overwrite
     |  the values of the command's options/attributes multiple times during the build
     |  process.
     |  Therefore it is important to consistently implement ``initialize_options()`` and
     |  ``finalize_options()``. For example, all derived attributes (or attributes that
     |  depend on the value of other attributes) **SHOULD** be recomputed in
     |  ``finalize_options``.
     |  
     |  When overwriting existing commands, custom defined classes **MUST** abide by the
     |  same APIs implemented by the original class. They also **SHOULD** inherit from the
     |  original class.
     |  
     |  Method resolution order:
     |      Command
     |      distutils.cmd.Command
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, dist, **kw)
     |      Construct the command for dist, updating
     |      vars(self) with any keyword parameters.
     |  
     |  ensure_string_list(self, option)
     |      Ensure that 'option' is a list of strings.  If 'option' is
     |      currently a string, we split it either on /,\s*/ or /\s+/, so
     |      "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
     |      ["foo", "bar", "baz"].
     |      
     |      ..
     |         TODO: This method seems to be similar to the one in ``distutils.cmd``
     |         Probably it is just here for backward compatibility with old Python versions?
     |      
     |      :meta private:
     |  
     |  reinitialize_command(self, command, reinit_subcommands=0, **kw)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  command_consumes_arguments = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from distutils.cmd.Command:
     |  
     |  __getattr__(self, attr)
     |      # XXX A more explicit way to customize dry_run would be better.
     |  
     |  announce(self, msg, level=1)
     |      If the current verbosity level is of greater than or equal to
     |      'level' print 'msg' to stdout.
     |  
     |  copy_file(self, infile, outfile, preserve_mode=1, preserve_times=1, link=None, level=1)
     |      Copy a file respecting verbose, dry-run and force flags.  (The
     |      former two default to whatever is in the Distribution object, and
     |      the latter defaults to false for commands that don't define it.)
     |  
     |  copy_tree(self, infile, outfile, preserve_mode=1, preserve_times=1, preserve_symlinks=0, level=1)
     |      Copy an entire directory tree respecting verbose, dry-run,
     |      and force flags.
     |  
     |  debug_print(self, msg)
     |      Print 'msg' to stdout if the global DEBUG (taken from the
     |      DISTUTILS_DEBUG environment variable) flag is true.
     |  
     |  dump_options(self, header=None, indent='')
     |  
     |  ensure_dirname(self, option)
     |  
     |  ensure_filename(self, option)
     |      Ensure that 'option' is the name of an existing file.
     |  
     |  ensure_finalized(self)
     |  
     |  ensure_string(self, option, default=None)
     |      Ensure that 'option' is a string; if not defined, set it to
     |      'default'.
     |  
     |  execute(self, func, args, msg=None, level=1)
     |  
     |  finalize_options(self)
     |      Set final values for all the options that this command supports.
     |      This is always called as late as possible, ie.  after any option
     |      assignments from the command-line or from other commands have been
     |      done.  Thus, this is the place to code option dependencies: if
     |      'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
     |      long as 'foo' still has the same value it was assigned in
     |      'initialize_options()'.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  get_command_name(self)
     |  
     |  get_finalized_command(self, command, create=1)
     |      Wrapper around Distribution's 'get_command_obj()' method: find
     |      (create if necessary and 'create' is true) the command object for
     |      'command', call its 'ensure_finalized()' method, and return the
     |      finalized command object.
     |  
     |  get_sub_commands(self)
     |      Determine the sub-commands that are relevant in the current
     |      distribution (ie., that need to be run).  This is based on the
     |      'sub_commands' class attribute: each tuple in that list may include
     |      a method that we call to determine if the subcommand needs to be
     |      run for the current distribution.  Return a list of command names.
     |  
     |  initialize_options(self)
     |      Set default values for all the options that this command
     |      supports.  Note that these defaults may be overridden by other
     |      commands, by the setup script, by config files, or by the
     |      command-line.  Thus, this is not the place to code dependencies
     |      between options; generally, 'initialize_options()' implementations
     |      are just a bunch of "self.foo = None" assignments.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  make_archive(self, base_name, format, root_dir=None, base_dir=None, owner=None, group=None)
     |  
     |  make_file(self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1)
     |      Special case of 'execute()' for operations that process one or
     |      more input files and generate one output file.  Works just like
     |      'execute()', except the operation is skipped and a different
     |      message printed if 'outfile' already exists and is newer than all
     |      files listed in 'infiles'.  If the command defined 'self.force',
     |      and it is true, then the command is unconditionally run -- does no
     |      timestamp checks.
     |  
     |  mkpath(self, name, mode=511)
     |  
     |  move_file(self, src, dst, level=1)
     |      Move a file respecting dry-run flag.
     |  
     |  run(self)
     |      A command's raison d'etre: carry out the action it exists to
     |      perform, controlled by the options initialized in
     |      'initialize_options()', customized by other commands, the setup
     |      script, the command-line, and config files, and finalized in
     |      'finalize_options()'.  All terminal output and filesystem
     |      interaction should be done by 'run()'.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  run_command(self, command)
     |      Run some other command: uses the 'run_command()' method of
     |      Distribution, which creates and finalizes the command object if
     |      necessary and then invokes its 'run()' method.
     |  
     |  set_undefined_options(self, src_cmd, *option_pairs)
     |      Set the values of any "undefined" options from corresponding
     |      option values in some other command object.  "Undefined" here means
     |      "is None", which is the convention used to indicate that an option
     |      has not been changed between 'initialize_options()' and
     |      'finalize_options()'.  Usually called from 'finalize_options()' for
     |      options that depend on some other command rather than another
     |      option of the same command.  'src_cmd' is the other command from
     |      which option values will be taken (a command object will be created
     |      for it if necessary); the remaining arguments are
     |      '(src_option,dst_option)' tuples which mean "take the value of
     |      'src_option' in the 'src_cmd' command object, and copy it to
     |      'dst_option' in the current command object".
     |  
     |  spawn(self, cmd, search_path=1, level=1)
     |      Spawn an external command respecting dry-run flag.
     |  
     |  warn(self, msg)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from distutils.cmd.Command:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from distutils.cmd.Command:
     |  
     |  sub_commands = []
    
    class Distribution(distutils.dist.Distribution)
     |  Distribution(attrs=None)
     |  
     |  Distribution with support for tests and package data
     |  
     |  This is an enhanced version of 'distutils.dist.Distribution' that
     |  effectively adds the following new optional keyword arguments to 'setup()':
     |  
     |   'install_requires' -- a string or sequence of strings specifying project
     |      versions that the distribution requires when installed, in the format
     |      used by 'pkg_resources.require()'.  They will be installed
     |      automatically when the package is installed.  If you wish to use
     |      packages that are not available in PyPI, or want to give your users an
     |      alternate download location, you can add a 'find_links' option to the
     |      '[easy_install]' section of your project's 'setup.cfg' file, and then
     |      setuptools will scan the listed web pages for links that satisfy the
     |      requirements.
     |  
     |   'extras_require' -- a dictionary mapping names of optional "extras" to the
     |      additional requirement(s) that using those extras incurs. For example,
     |      this::
     |  
     |          extras_require = dict(reST = ["docutils>=0.3", "reSTedit"])
     |  
     |      indicates that the distribution can optionally provide an extra
     |      capability called "reST", but it can only be used if docutils and
     |      reSTedit are installed.  If the user installs your package using
     |      EasyInstall and requests one of your extras, the corresponding
     |      additional requirements will be installed if needed.
     |  
     |   'test_suite' -- the name of a test suite to run for the 'test' command.
     |      If the user runs 'python setup.py test', the package will be installed,
     |      and the named test suite will be run.  The format is the same as
     |      would be used on a 'unittest.py' command line.  That is, it is the
     |      dotted name of an object to import and call to generate a test suite.
     |  
     |   'package_data' -- a dictionary mapping package names to lists of filenames
     |      or globs to use to find data files contained in the named packages.
     |      If the dictionary has filenames or globs listed under '""' (the empty
     |      string), those names will be searched for in every package, in addition
     |      to any names for the specific package.  Data files found using these
     |      names/globs will be installed along with the package, in the same
     |      location as the package.  Note that globs are allowed to reference
     |      the contents of non-package subdirectories, as long as you use '/' as
     |      a path separator.  (Globs are automatically converted to
     |      platform-specific paths at runtime.)
     |  
     |  In addition to these new keywords, this class also has several new methods
     |  for manipulating the distribution's contents.  For example, the 'include()'
     |  and 'exclude()' methods can be thought of as in-place add and subtract
     |  commands that add or remove packages, modules, extensions, and so on from
     |  the distribution.
     |  
     |  Method resolution order:
     |      Distribution
     |      distutils.dist.Distribution
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, attrs=None)
     |      Construct a new Distribution instance: initialize all the
     |      attributes of a Distribution, and then use 'attrs' (a dictionary
     |      mapping attribute names to values) to assign some of those
     |      attributes their "real" values.  (Any attributes not mentioned in
     |      'attrs' will be assigned to some null value: 0, None, an empty list
     |      or dictionary, etc.)  Most importantly, initialize the
     |      'command_obj' attribute to the empty dictionary; this will be
     |      filled in with real command objects by 'parse_command_line()'.
     |  
     |  exclude(self, **attrs)
     |      Remove items from distribution that are named in keyword arguments
     |      
     |      For example, 'dist.exclude(py_modules=["x"])' would remove 'x' from
     |      the distribution's 'py_modules' attribute.  Excluding packages uses
     |      the 'exclude_package()' method, so all of the package's contained
     |      packages, modules, and extensions are also excluded.
     |      
     |      Currently, this method only supports exclusion from attributes that are
     |      lists or tuples.  If you need to add support for excluding from other
     |      attributes in this or a subclass, you can add an '_exclude_X' method,
     |      where 'X' is the name of the attribute.  The method will be called with
     |      the value passed to 'exclude()'.  So, 'dist.exclude(foo={"bar":"baz"})'
     |      will try to call 'dist._exclude_foo({"bar":"baz"})', which can then
     |      handle whatever special exclusion logic is needed.
     |  
     |  exclude_package(self, package)
     |      Remove packages, modules, and extensions in named package
     |  
     |  fetch_build_egg(self, req)
     |      Fetch an egg needed for building
     |  
     |  fetch_build_eggs(self, requires)
     |      Resolve pre-setup requirements
     |  
     |  finalize_options(self)
     |      Allow plugins to apply arbitrary operations to the
     |      distribution. Each hook may optionally define a 'order'
     |      to influence the order of execution. Smaller numbers
     |      go first and the default is 0.
     |  
     |  get_cmdline_options(self)
     |      Return a '{cmd: {opt:val}}' map of all command-line options
     |      
     |      Option names are all long, but do not include the leading '--', and
     |      contain dashes rather than underscores.  If the option doesn't take
     |      an argument (e.g. '--quiet'), the 'val' is 'None'.
     |      
     |      Note that options provided by config files are intentionally excluded.
     |  
     |  get_command_class(self, command)
     |      Pluggable version of get_command_class()
     |  
     |  get_command_list(self)
     |      Get a list of (command, description) tuples.
     |      The list is divided into "standard commands" (listed in
     |      distutils.command.__all__) and "extra commands" (mentioned in
     |      self.cmdclass, but not a standard command).  The descriptions come
     |      from the command class attribute 'description'.
     |  
     |  get_egg_cache_dir(self)
     |  
     |  handle_display_options(self, option_order)
     |      If there were any non-global "display-only" options
     |      (--help-commands or the metadata display options) on the command
     |      line, display the requested info and return true; else return
     |      false.
     |  
     |  has_contents_for(self, package)
     |      Return true if 'exclude_package(package)' would do something
     |  
     |  include(self, **attrs)
     |      Add items to distribution that are named in keyword arguments
     |      
     |      For example, 'dist.include(py_modules=["x"])' would add 'x' to
     |      the distribution's 'py_modules' attribute, if it was not already
     |      there.
     |      
     |      Currently, this method only supports inclusion for attributes that are
     |      lists or tuples.  If you need to add support for adding to other
     |      attributes in this or a subclass, you can add an '_include_X' method,
     |      where 'X' is the name of the attribute.  The method will be called with
     |      the value passed to 'include()'.  So, 'dist.include(foo={"bar":"baz"})'
     |      will try to call 'dist._include_foo({"bar":"baz"})', which can then
     |      handle whatever special inclusion logic is needed.
     |  
     |  iter_distribution_names(self)
     |      Yield all packages, modules, and extension names in distribution
     |  
     |  make_option_lowercase(self, opt, section)
     |  
     |  parse_config_files(self, *args, **kwargs)
     |  
     |  patch_missing_pkg_info(self, attrs)
     |  
     |  print_commands(self)
     |      Print out a help message listing all available commands with a
     |      description of each.  The list is divided into "standard commands"
     |      (listed in distutils.command.__all__) and "extra commands"
     |      (mentioned in self.cmdclass, but not a standard command).  The
     |      descriptions come from the command class attribute
     |      'description'.
     |  
     |  run_command(self, command)
     |      Do whatever it takes to run a command (including nothing at all,
     |      if the command has already been run).  Specifically: if we have
     |      already created and run the command named by 'command', return
     |      silently without doing anything.  If the command named by 'command'
     |      doesn't even have a command object yet, create one.  Then invoke
     |      'run()' on that command object (or an existing one).
     |  
     |  warn_dash_deprecation(self, opt, section)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from distutils.dist.Distribution:
     |  
     |  announce(self, msg, level=2)
     |  
     |  dump_option_dicts(self, header=None, commands=None, indent='')
     |  
     |  find_config_files(self)
     |      Find as many configuration files as should be processed for this
     |      platform, and return a list of filenames in the order in which they
     |      should be parsed.  The filenames returned are guaranteed to exist
     |      (modulo nasty race conditions).
     |      
     |      There are multiple possible config files:
     |      - distutils.cfg in the Distutils installation directory (i.e.
     |        where the top-level Distutils __inst__.py file lives)
     |      - a file in the user's home directory named .pydistutils.cfg
     |        on Unix and pydistutils.cfg on Windows/Mac; may be disabled
     |        with the ``--no-user-cfg`` option
     |      - setup.cfg in the current directory
     |      - a file named by an environment variable
     |  
     |  get_command_obj(self, command, create=1)
     |      Return the command object for 'command'.  Normally this object
     |      is cached on a previous call to 'get_command_obj()'; if no command
     |      object for 'command' is in the cache, then we either create and
     |      return it (if 'create' is true) or return None.
     |  
     |  get_command_packages(self)
     |      Return a list of packages from which commands are loaded.
     |  
     |  get_option_dict(self, command)
     |      Get the option dictionary for a given command.  If that
     |      command's option dictionary hasn't been created yet, then create it
     |      and return the new dictionary; otherwise, return the existing
     |      option dictionary.
     |  
     |  has_c_libraries(self)
     |  
     |  has_data_files(self)
     |  
     |  has_ext_modules(self)
     |  
     |  has_headers(self)
     |  
     |  has_modules(self)
     |  
     |  has_pure_modules(self)
     |  
     |  has_scripts(self)
     |  
     |  is_pure(self)
     |  
     |  parse_command_line(self)
     |      Parse the setup script's command line, taken from the
     |      'script_args' instance attribute (which defaults to 'sys.argv[1:]'
     |      -- see 'setup()' in core.py).  This list is first processed for
     |      "global options" -- options that set attributes of the Distribution
     |      instance.  Then, it is alternately scanned for Distutils commands
     |      and options for that command.  Each new command terminates the
     |      options for the previous command.  The allowed options for a
     |      command are determined by the 'user_options' attribute of the
     |      command class -- thus, we have to be able to load command classes
     |      in order to parse the command line.  Any error in that 'options'
     |      attribute raises DistutilsGetoptError; any error on the
     |      command-line raises DistutilsArgError.  If no Distutils commands
     |      were found on the command line, raises DistutilsArgError.  Return
     |      true if command-line was successfully parsed and we should carry
     |      on with executing commands; false if no errors but we shouldn't
     |      execute commands (currently, this only happens if user asks for
     |      help).
     |  
     |  print_command_list(self, commands, header, max_length)
     |      Print a subset of the list of all commands -- used by
     |      'print_commands()'.
     |  
     |  reinitialize_command(self, command, reinit_subcommands=0)
     |      Reinitializes a command to the state it was in when first
     |      returned by 'get_command_obj()': ie., initialized but not yet
     |      finalized.  This provides the opportunity to sneak option
     |      values in programmatically, overriding or supplementing
     |      user-supplied values from the config files and command line.
     |      You'll have to re-finalize the command object (by calling
     |      'finalize_options()' or 'ensure_finalized()') before using it for
     |      real.
     |      
     |      'command' should be a command name (string) or command object.  If
     |      'reinit_subcommands' is true, also reinitializes the command's
     |      sub-commands, as declared by the 'sub_commands' class attribute (if
     |      it has one).  See the "install" command for an example.  Only
     |      reinitializes the sub-commands that actually matter, ie. those
     |      whose test predicates return true.
     |      
     |      Returns the reinitialized command object.
     |  
     |  run_commands(self)
     |      Run each command that was seen on the setup script command line.
     |      Uses the list of commands found and cache of command objects
     |      created by 'get_command_obj()'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from distutils.dist.Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from distutils.dist.Distribution:
     |  
     |  common_usage = "Common commands: (see '--help-commands' for more...'\n...
     |  
     |  display_option_names = ['help_commands', 'name', 'version', 'fullname'...
     |  
     |  display_options = [('help-commands', None, 'list all available command...
     |  
     |  global_options = [('verbose', 'v', 'run verbosely (default)', 1), ('qu...
     |  
     |  negative_opt = {'quiet': 'verbose'}
    
    class Extension(distutils.extension.Extension)
     |  Extension(name, sources, *args, **kw)
     |  
     |  Describes a single extension module.
     |  
     |  This means that all source files will be compiled into a single binary file
     |  ``<module path>.<suffix>`` (with ``<module path>`` derived from ``name`` and
     |  ``<suffix>`` defined by one of the values in
     |  ``importlib.machinery.EXTENSION_SUFFIXES``).
     |  
     |  In the case ``.pyx`` files are passed as ``sources and`` ``Cython`` is **not**
     |  installed in the build environment, ``setuptools`` may also try to look for the
     |  equivalent ``.cpp`` or ``.c`` files.
     |  
     |  :arg str name:
     |    the full name of the extension, including any packages -- ie.
     |    *not* a filename or pathname, but Python dotted name
     |  
     |  :arg list[str] sources:
     |    list of source filenames, relative to the distribution root
     |    (where the setup script lives), in Unix form (slash-separated)
     |    for portability.  Source files may be C, C++, SWIG (.i),
     |    platform-specific resource files, or whatever else is recognized
     |    by the "build_ext" command as source for a Python extension.
     |  
     |  :keyword list[str] include_dirs:
     |    list of directories to search for C/C++ header files (in Unix
     |    form for portability)
     |  
     |  :keyword list[tuple[str, str|None]] define_macros:
     |    list of macros to define; each macro is defined using a 2-tuple:
     |    the first item corresponding to the name of the macro and the second
     |    item either a string with its value or None to
     |    define it without a particular value (equivalent of "#define
     |    FOO" in source or -DFOO on Unix C compiler command line)
     |  
     |  :keyword list[str] undef_macros:
     |    list of macros to undefine explicitly
     |  
     |  :keyword list[str] library_dirs:
     |    list of directories to search for C/C++ libraries at link time
     |  
     |  :keyword list[str] libraries:
     |    list of library names (not filenames or paths) to link against
     |  
     |  :keyword list[str] runtime_library_dirs:
     |    list of directories to search for C/C++ libraries at run time
     |    (for shared extensions, this is when the extension is loaded).
     |    Setting this will cause an exception during build on Windows
     |    platforms.
     |  
     |  :keyword list[str] extra_objects:
     |    list of extra files to link with (eg. object files not implied
     |    by 'sources', static library that must be explicitly specified,
     |    binary resource files, etc.)
     |  
     |  :keyword list[str] extra_compile_args:
     |    any extra platform- and compiler-specific information to use
     |    when compiling the source files in 'sources'.  For platforms and
     |    compilers where "command line" makes sense, this is typically a
     |    list of command-line arguments, but for other platforms it could
     |    be anything.
     |  
     |  :keyword list[str] extra_link_args:
     |    any extra platform- and compiler-specific information to use
     |    when linking object files together to create the extension (or
     |    to create a new static Python interpreter).  Similar
     |    interpretation as for 'extra_compile_args'.
     |  
     |  :keyword list[str] export_symbols:
     |    list of symbols to be exported from a shared extension.  Not
     |    used on all platforms, and not generally necessary for Python
     |    extensions, which typically export exactly one symbol: "init" +
     |    extension_name.
     |  
     |  :keyword list[str] swig_opts:
     |    any extra options to pass to SWIG if a source file has the .i
     |    extension.
     |  
     |  :keyword list[str] depends:
     |    list of files that the extension depends on
     |  
     |  :keyword str language:
     |    extension language (i.e. "c", "c++", "objc"). Will be detected
     |    from the source extensions if not provided.
     |  
     |  :keyword bool optional:
     |    specifies that a build failure in the extension should not abort the
     |    build process, but simply not install the failing extension.
     |  
     |  :keyword bool py_limited_api:
     |    opt-in flag for the usage of :doc:`Python's limited API <python:c-api/stable>`.
     |  
     |  :raises setuptools.errors.PlatformError: if 'runtime_library_dirs' is
     |    specified on Windows. (since v63)
     |  
     |  Method resolution order:
     |      Extension
     |      distutils.extension.Extension
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, sources, *args, **kw)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from distutils.extension.Extension:
     |  
     |  __repr__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from distutils.extension.Extension:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Require(builtins.object)
     |  Require(name, requested_version, module, homepage='', attribute=None, format=None)
     |  
     |  A prerequisite to building or installing a distribution
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, requested_version, module, homepage='', attribute=None, format=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  full_name(self)
     |      Return full package/distribution name, w/version
     |  
     |  get_version(self, paths=None, default='unknown')
     |      Get version number of installed module, 'None', or 'default'
     |      
     |      Search 'paths' for module.  If not found, return 'None'.  If found,
     |      return the extracted version attribute, or 'default' if no version
     |      attribute was specified, or the value cannot be determined without
     |      importing the module.  The version is formatted according to the
     |      requirement's version format (if any), unless it is 'None' or the
     |      supplied 'default'.
     |  
     |  is_current(self, paths=None)
     |      Return true if dependency is present and up-to-date on 'paths'
     |  
     |  is_present(self, paths=None)
     |      Return true if dependency is present on 'paths'
     |  
     |  version_ok(self, version)
     |      Is 'version' sufficiently up-to-date?
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class SetuptoolsDeprecationWarning(builtins.Warning)
     |  Base class for warning deprecations in ``setuptools``
     |  
     |  This class is not derived from ``DeprecationWarning``, and as such is
     |  visible by default.
     |  
     |  Method resolution order:
     |      SetuptoolsDeprecationWarning
     |      builtins.Warning
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Warning:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Warning:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    find_namespace_packages = find(where: Union[str, os.PathLike] = '.', exclude: Iterable[str] = (), include: Iterable[str] = ('*',)) -> List[str] method of builtins.type instance
        Return a list of all Python items (packages or modules, depending on
        the finder implementation) found within directory 'where'.
        
        'where' is the root directory which will be searched.
        It should be supplied as a "cross-platform" (i.e. URL-style) path;
        it will be converted to the appropriate local path syntax.
        
        'exclude' is a sequence of names to exclude; '*' can be used
        as a wildcard in the names.
        When finding packages, 'foo.*' will exclude all subpackages of 'foo'
        (but not 'foo' itself).
        
        'include' is a sequence of names to include.
        If it's specified, only the named items will be included.
        If it's not specified, all found items will be included.
        'include' can contain shell style wildcard patterns just like
        'exclude'.
    
    find_packages = find(where: Union[str, os.PathLike] = '.', exclude: Iterable[str] = (), include: Iterable[str] = ('*',)) -> List[str] method of builtins.type instance
        Return a list of all Python items (packages or modules, depending on
        the finder implementation) found within directory 'where'.
        
        'where' is the root directory which will be searched.
        It should be supplied as a "cross-platform" (i.e. URL-style) path;
        it will be converted to the appropriate local path syntax.
        
        'exclude' is a sequence of names to exclude; '*' can be used
        as a wildcard in the names.
        When finding packages, 'foo.*' will exclude all subpackages of 'foo'
        (but not 'foo' itself).
        
        'include' is a sequence of names to include.
        If it's specified, only the named items will be included.
        If it's not specified, all found items will be included.
        'include' can contain shell style wildcard patterns just like
        'exclude'.
    
    setup(**attrs)
        The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
        
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
        
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
        
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.

DATA
    __all__ = ['setup', 'Distribution', 'Command', 'Extension', 'Require',...

VERSION
    65.5.1

FILE
    p:\anqi\desktop\tech\python\projects\help\venv\lib\site-packages\setuptools\__init__.py


